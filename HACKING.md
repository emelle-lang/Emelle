# Hacking on the Emelle compiler

The compiler is separated into the Emelle library, located in `src/`, and the
Emelle executable, located in `app/`. The Emelle library does not depend on
Stdio, so it may be compiled to JavaScript. The Emelle executable performs the
IO.

The modules of Emelle are as follows:

`Emelle.Lexing`

This module contains the lexer, which is generated by OCamllex.

`Emelle.Parsing`

This module contains the parser, which is generated by Menhir.

`Emelle.Ast`

This module defines the abstract syntax tree, the output of the parser.

`Emelle.Kind`

This module defines the kind, the arity of a type.

`Emelle.Type`

This module defines the type representation that type type checker operates on.

`Emelle.Term`

This module defines the core term representation that the type checker operates
on.

`Emelle.Env`

This module defines an immutable scoped "environment" data structure for
resolving locally defined names. It merges frames into a single tree map to
avoid the linear chain of name lookup between frames.

`Emelle.Desugar`

This module converts the AST into the core form of `Emelle.Term`. It:

- Replaces user-written paths with fully qualified `Ident.t`s
- Replaces locally defined names with integer unique "registers"
- Tags patterns with registers to store their scrutinees
- Converts data constructor names with integers in definition order

`Emelle.Typecheck`

This module contains the typechecker, an implementation of Hindley-Milner type
inference with higher-kinded types. It verifies that the `Emelle.Term`
representation is type-safe.

`Emelle.Pattern`

This module implements the algorithms defined in the paper "Compiling Pattern
Matching to Good Decision Trees" by Luc Maranget.



You will often see the `>>=` and `>>|` operators in the code. `>>=` is monadic
bind, and `>>|` is `map` with the arguments reversed (the functor comes first
and the function comes second). These operators are used with the result type
to compose computations that may fail.
